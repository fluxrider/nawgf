<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1" />
<title>Demo</title>
<link rel="preload" href="alkhemikal_cc_by_jeti_4.0.ttf" as="font" crossorigin="anonymous" />
<style>
#my_canvas {
  width: 510px; height: 270px;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
@font-face { font-family: 'Alkhemikal'; src: url('alkhemikal_cc_by_jeti_4.0.ttf'); }
</style>
<script>
var is_fill = false;
var key_held = false;
var mouse_y = 0;
var mouse_x = 0;
var debug_msg = "";
var aspect = null;
var gamecontrollerdb = null;

function my_onload() {
  let canvas = document.getElementById("my_canvas");
  canvas.addEventListener('fullscreenchange', (event) => {
    // on enter fullscreen
    if(document.fullscreenElement) {
      canvas.style.border = 0;
      aspect = calculate_fill(canvas.width, canvas.height, canvas.clientWidth, canvas.clientHeight);
    }
    // on exit fullscreen
    else {
      canvas.style.border = is_fill? 0 : "1px solid rgb(255, 0, 0)";
    }
  });
  // mouse
  canvas.addEventListener('mousemove', function(event) {
    mouse_y = event.pageY - (canvas.offsetTop + canvas.clientTop);
    mouse_x = event.pageX - (canvas.offsetLeft + canvas.clientLeft);
    // TODO precalculate taking into account fullscreen letterbox
    let W = canvas.clientWidth; let H = canvas.clientHeight;
    if(document.fullscreenElement) {
      W = aspect.w; H = aspect.h;
      mouse_y -= aspect.y;
      mouse_x -= aspect.x;
    }
    // normalize
    mouse_y = mouse_y * canvas.height / H;
    mouse_x = mouse_x * canvas.width / W;
    if(mouse_x < 0) mouse_x = 0; if(mouse_x > canvas.width) mouse_x = canvas.width;
    if(mouse_y < 0) mouse_y = 0; if(mouse_y > canvas.height) mouse_y = canvas.height;
  });
}

function my_fullscreen() {
  //alert(document.fullscreenEnabled);
  let canvas = document.getElementById("my_canvas");
  canvas.requestFullscreen().catch(err => {
    alert("Error attempting to enable full-screen mode: " + err.message + " " + err.name);
  });
}
function my_fill_toggle() {
  let canvas = document.getElementById("my_canvas");
  // unfill window
  if(is_fill) {
    canvas.style.width = "510px";
    canvas.style.height = "270px";
    canvas.style.border = (document.fullscreenElement != null)? 0 : "1px solid rgb(255, 0, 0)";
    // reset margin and padding
    document.body.style.margin = ""; document.body.style.padding = "";
  }
  // fill window
  else {
    canvas.style.border = 0;
    document.body.style.margin = 0; document.body.style.padding = 0;
    my_fill();
  }
  is_fill = !is_fill;
}
function my_fill() {
  let canvas = document.getElementById("my_canvas");
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";

  // respect aspect ratio of canvas buffer
  const {aspectH, aspectW, offsetY, offsetX} = calculate_fill(canvas.width, canvas.height, canvas.clientWidth, canvas.clientHeight);
  canvas.style.width = (aspectW / canvas.clientWidth * 100) + "vw";
  canvas.style.height = (aspectH / canvas.clientHeight * 100) + "vh";
  // TODO this is sometime flush, but in other times there are sliders
}

function calculate_fill(w, h, W, H) {
  let a = w / h;
  let A = W / H;
  let offsetX = 0;
  let offsetY = 0;
  let aspectW = W;
  let aspectH = H;
  // top/down black bars
  if (a / A > 1) {
    aspectH = W * h / w;
    offsetY = (H - aspectH) / 2;
  }
  // left/right black bars
  else {
    aspectW = H * w / h;
    offsetX = (W - aspectW) / 2;
  }
  return {
    h: aspectH,
    w: aspectW,
    y: offsetY,
    x: offsetX
  };
}

var frame = 0;
var t0 = null;
function my_render(t1) {
  // input
  const gamepads = navigator.getGamepads();
  joy_msg = "";
  for(const gamepad of gamepads) {
    if(!(gamepad && gamepad.connected)) continue;
    //joy_msg += gamepad.id + " " + gamepad.mapping + " " + gamepad.buttons[0].pressed;
    // gamepad.id example:
    //  chromium: "8BitDo N30 Pro 2 (Vendor: 2dc8 Product: 2865)"
    //  firefox: "2dc8-2865-8BitDo N30 Pro 2"
    // on my end there is no mapping (i.e. it is not set to "standard", and buttons[0] is east instead of south)
    // it should be possible to match an SDL2 mapping. You can see the vendor/product bytes in there
    // 05000000c82d00006528000000010000,8BitDo N30 Pro 2,a:b1,b:b0,back:b10,dpdown:h0.4,dpleft:h0.8,dpright:h0.2,dpup:h0.1,leftshoulder:b6,leftstick:b13,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b14,righttrigger:b9,rightx:a2,righty:a3,start:b11,x:b4,y:b3,platform:Linux,
    // fun fun, the SDL names are pretty lame/non-descript/xbox-loving (e.g. a, b) and the web "standard" mapping don't even have names.
    // but SDL south is called a, east -- b, north -- y, select -- back, L1 -- leftshoulder, L2 -- lefttrigger, L3 -- leftstick, the rest is obvious enough
    // the web "standard" numbers can be found at https://www.w3.org/TR/gamepad/standard_gamepad.svg
    let mapping = null;
    if(!gamepad.mapping && gamecontrollerdb) {
      let OS = 'Linux';
// TODO navigator.userAgent
// chrome: 5.0 (X11; CrOS armv7l 12371.89.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36
// firefox: 5.0 (X11; Linux ....)
// default to linux?
      let vendor = null;
      let product = null;
      let name = null;
      // parse chromium style id
      {
      let match = gamepad.id.match(/(.*)\s\(Vendor:\s(.*)\sProduct:\s(.*)\).*/); if(match && match[1] && match[2] && match[3]) { name = match[1]; vendor = match[2]; product = match[3]; } else {
      // parse firefox style id
      let match = gamepad.id.match(/(.*)-(.*)-(.*)/); if(match && match[1] && match[2] && match[3]) { name = match[3]; vendor = match[1]; product = match[2]; }
      }}
      //debug_msg = `${OS}, ${vendor}, ${product}, ${name}`;
      if(vendor) {
        partial_guid = vendor[2] + vendor[3] + vendor[0] + vendor[1] + '0000' + product[2] + product[3] + product[0] + product[1];

        // find entries in gamecontrollerdb that matches
        let pattern = `.*${partial_guid}(.*)\n`;
        let re = new RegExp(pattern, "g");
        let match = gamecontrollerdb.match(re);
        let line = null;
        for(const m of match) {
          if(m.endsWith(OS + ',\n')) line = m;
        }
        if(!line) line = m[1]; // pick the first OS if none matched
        debug_msg = line;
      }
    }
    if(!mapping) {
      // cross our fingers falling back to the "standard" mapping
      mapping = {
        up: gamepad.buttons.length >= 13? gamepad.buttons[12].pressed : false,
        down: gamepad.buttons.length >= 14? gamepad.buttons[13].pressed : false,
        left: gamepad.buttons.length >= 15? gamepad.buttons[14].pressed : false,
        right: gamepad.buttons.length >= 16? gamepad.buttons[15].pressed : false,
        north: gamepad.buttons.length >= 4? gamepad.buttons[3].pressed : false,
        south: gamepad.buttons.length >= 1? gamepad.buttons[0].pressed : false,
        west: gamepad.buttons.length >= 3? gamepad.buttons[2].pressed : false,
        east: gamepad.buttons.length >= 2? gamepad.buttons[1].pressed : false,
        start: gamepad.buttons.length >= 10? gamepad.buttons[9].pressed : false,
        select: gamepad.buttons.length >= 9? gamepad.buttons[8].pressed : false,
        L1: gamepad.buttons.length >= 5? gamepad.buttons[4].pressed : false,
        L2: gamepad.buttons.length >= 7? gamepad.buttons[6] : 0,
        L3: gamepad.buttons.length >= 11? gamepad.buttons[10].pressed : false,
        R1: gamepad.buttons.length >= 6? gamepad.buttons[5].pressed : false,
        R2: gamepad.buttons.length >= 8? gamepad.buttons[7] : 0,
        R3: gamepad.buttons.length >= 12? gamepad.buttons[11].pressed : false,
        LX: gamepad.axes.length >= 1? gamepad.axes[0] : 0,
        LY: gamepad.axes.length >= 2? gamepad.axes[1] : 0,
        RX: gamepad.axes.length >= 3? gamepad.axes[2] : 0,
        RY: gamepad.axes.length >= 4? gamepad.axes[3] : 0,
        HOME: gamepad.buttons.length >= 17? gamepad.buttons[16].pressed : false
      };
    }
    joy_msg += "south: " + mapping.south + " LY: " + mapping.LY;
  }

  // gfx
  let canvas = document.getElementById("my_canvas");
  let w = canvas.width;
  let h = canvas.height;
  let g = canvas.getContext("2d");
  if(!t0) t0 = t1;
  let dt = (t1 - t0) / 1000;

  // Create gradient
  let grd = g.createLinearGradient(0, 0, w, 0);
  grd.addColorStop(0, "red");
  grd.addColorStop(1, "white");

  // Fill with gradient
  g.fillStyle = 'green';
  g.fillRect(0, 0, w, h);
  g.fillStyle = grd;
  g.fillRect(10, 10, w - 20, h - 20);
  
  //var image = new Image();
  //image.onload = function () {
  //  g.drawImage(image, 0, 0);
  //}
  //image.src = 'cat.png';

  g.font = '18px Alkhemikal';
  g.fillStyle = "black";
  g.strokeStyle = "white";
  g.fillText("key held: " + key_held, 30, 30);
  g.fillText("frame: " + frame++, 30, 60);
  g.strokeText("t: " + t1, 30, 90);
  g.fillText("t: " + t1, 30, 90);
  g.fillText(`dt: ${dt.toFixed(3)} (${(1/dt).toFixed(1)})`, 30, 120);
  g.fillText(`mouse: ${mouse_x}, ${mouse_y}`, 30, 150);
  g.fillText("gamecontrollerdb: " + (gamecontrollerdb != null), 30, 180);
  g.fillText(`gamepad: ${joy_msg}`, 30, 210);
  g.fillText(`debug: ${debug_msg}`, 30, 240);

  requestAnimationFrame(my_render);
  t0 = t1;
}

window.addEventListener('resize', function() {
  let is_fullscreen = document.fullscreenElement != null;
  if(is_fullscreen) {
    let canvas = document.getElementById("my_canvas");
    aspect = calculate_fill(canvas.width, canvas.height, canvas.clientWidth, canvas.clientHeight);
  } else if(is_fill) {
    my_fill();
  }
});

document.addEventListener('keydown', function my_keydown(event) {
  if(event.keyCode == 39) {
    key_held = true;
    event.preventDefault();
  }
});
document.addEventListener('keyup', function my_keyup(event) {
  if(event.keyCode == 39) {
    key_held = false;
    event.preventDefault();
  }
});

function my_network() {
  fetch('https://raw.githubusercontent.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt').then(function(response) {
    return response.text().then(function(text) {
      gamecontrollerdb = text;
    });
  });
  
}
</script>
</head><body onload="my_onload();">
<canvas id="my_canvas" width="510" height="270" style="border:1px solid #FF0000;"/></canvas>
<p onclick="requestAnimationFrame(my_render);">render</p>
<p onclick="my_fullscreen();">fullscreen</p>
<p onclick="my_fill_toggle();">fill</p>
<p onclick="my_network();">network test</p>
</body></html>
